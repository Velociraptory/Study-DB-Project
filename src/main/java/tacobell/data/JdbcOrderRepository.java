package tacobell.data;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;
import tacobell.Order;
import tacobell.Taco;

import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
@Repository
public class JdbcOrderRepository implements OrderRepository {
    private SimpleJdbcInsert orderInserter;
    private SimpleJdbcInsert orderTacoInserter;
    private ObjectMapper objectMapper;

    /**Like JdbcTacoRepository, JdbcOrderRepository is injected with JdbcTemplate
     through it's constructor. But instead of assigning JdbcTemplate directly to an instance
     variable, the constructor uses it to construct a couple of SimpleJdbcInsert instances.*/
    @Autowired
    public JdbcOrderRepository(JdbcTemplate jdbc) {
        /**orderInserter instance variable, is configured
        to work with the Taco_Order table and to assume that the id property will be
        provided or generated by the database*/
        this.orderInserter = new SimpleJdbcInsert(jdbc)
                .withTableName("Taco_Order")
                .usingGeneratedKeyColumns("id");
        /**TacoInserter, is configured to work with the Taco_Order_Tacos table but makes no
        claims about how any IDs will be generated in that table*/
        this.orderTacoInserter = new SimpleJdbcInsert(jdbc)
                .withTableName("Taco_Order_Tacos");

        this.objectMapper = new ObjectMapper();
    }

    /**save() defines the flow for saving an
    Order and its associated Taco objects, and delegates the persistence work to save-
    OrderDetails() and saveTacoToOrder()*/
    @Override
    public Order save(Order order) {
        order.setPlacedAt(new Date());
        long orderId = saveOrderDetails(order);
        order.setId(orderId);
        List<Taco> tacos = order.getTacos();
        for (Taco taco : tacos) {
            saveTacoToOrder(taco, orderId);
        }
        return order;
    }
    /**SimpleJdbcInsert has a couple of useful methods for executing the insert:
     execute() and executeAndReturnKey(). Both accept a Map<String, Object>, where
     the map keys correspond to the column names in the table the data is inserted into.
     The map values are inserted into those columns.*/
    private long saveOrderDetails(Order order) {
        @SuppressWarnings("unchecked")
        /**converting an Order into a Map by using Jacksonâ€™s ObjectMapper convertValue() method.
        Using ObjectMapper to map an object into a Map is much easier than
        copying each property from the object into the Map*/
        Map<String, Object> values = objectMapper.convertValue(order, Map.class);

        //values.put("id", 2); //setting order id
        values.put("placedAt", order.getPlacedAt()); //setting order date
        log.info(values.toString()); //debugging

        /**save the order information to the Taco_Order table and
         return the database-generated ID as a Number object*/
        long orderId = orderInserter.executeAndReturnKey(values)
                .longValue(); //convert Number object to long
        return orderId;
    }
    private void saveTacoToOrder(Taco taco, long orderId) {
        /**Rather than use the ObjectMapper to convert an object to a Map,
         we're create the Map and set the appropriate values.
         Once again, the map keys correspond to column names in the table.*/
        Map<String, Object> values = new HashMap<>();
        values.put("tacoOrder", orderId);
        values.put("taco", taco.getId());
        orderTacoInserter.execute(values); //perform the insert into Taco_Orders_Taco
    }
}
